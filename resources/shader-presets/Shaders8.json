{
  "id": "Shaders8",
  "isDefault": false,
  "vertex": "// Vertex Shader: Pass through position and UVs\n// No version directive needed, Three.js injects it\n\nvarying vec2 vUv; // Pass UV coordinates to Fragment Shader\n\nvoid main() {\n  // Use built-in 'position' and 'uv' attributes\n  vUv = uv;\n  // Output the clip-space position\n  gl_Position = vec4(position, 1.0);\n}",
  "fragment": "precision mediump float; // Set default float precision\n\n// Uniforms passed from Three.js\nuniform float u_time;       // Animation time in seconds\nuniform vec2  u_resolution; // Viewport resolution in pixels\nuniform vec2  u_mouse;      // Mouse position normalized to [0, 1]\nuniform float u_intensity;  // General intensity control [0, 1]\n\n// Varyings received from Vertex Shader\nvarying vec2 vUv; // Interpolated UV coordinates [0, 1]\n\n// --- Constants for Artistic Control ---\nconst float BASE_SPEED = 0.1;        // Base speed for the animation patterns\nconst float NOISE_SCALE = 4.0;       // Controls the scale of the noise patterns\nconst float CIRCLE_COUNT = 5.0;      // Number of concentric circle sets\nconst float BASE_THICKNESS = 0.01;   // Base thickness of the glowing lines\nconst float COLOR_SHIFT_AMOUNT = 0.015; // Base amount for chromatic aberration\nconst vec3 COLOR_1 = vec3(0.1, 0.0, 0.3); // Dark purple base\nconst vec3 COLOR_2 = vec3(1.0, 0.2, 0.5); // Bright pink/magenta glow\nconst vec3 COLOR_3 = vec3(0.3, 0.5, 1.0); // Bright cyan/blue glow\nconst float MOUSE_EFFECT_SCALE = 2.0; // How much the mouse interaction scales up with intensity\n\n// --- Helper Functions ---\n\n// 2D Rotation\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// Simple Pseudo-Random Noise (Hash)\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Smooth Minimum function\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Mouse Influence Function\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    return 1.0 - smoothstep(0.0, radius, dist * (1.0 / max(0.01, strength)));\n}\n\n// *** NEW FUNCTION: Replaces the lambda ***\n// Calculates the line value based on UV and other parameters\nfloat calculateLinePattern(vec2 sampleUv, float noiseValue, float intensity, float frequency, float thick, float sharp) {\n    float d = length(sampleUv) + noiseValue * 0.05 * (1.0 + intensity * 2.0); // Recalc perturbed dist\n    float cp = sin(d * 3.14159 * 2.0 * frequency); // Use frequency parameter\n    return smoothstep(1.0 - thick - sharp, 1.0 - thick, cp) - // Use thick and sharp parameters\n           smoothstep(1.0 - sharp, 1.0, cp);\n}\n\n\n// --- Main Shader Logic ---\nvoid main() {\n    // --- 1. Mouse Interaction Setup ---\n    float mouseRadius = 0.15 + u_intensity * 0.3 * MOUSE_EFFECT_SCALE;\n    float mouseStrength = 0.4 + u_intensity * 0.6 * MOUSE_EFFECT_SCALE;\n    float mouseFactor = mouseInfluence(vUv, u_mouse, mouseRadius, mouseStrength); // Closer to 0 means closer to mouse\n\n    // --- 2. Coordinate Manipulation ---\n    vec2 uv = vUv - 0.5;\n    uv.x *= u_resolution.x / u_resolution.y;\n\n    float distortionMag = (1.0 - mouseFactor) * (0.3 + u_intensity * 0.5);\n    vec2 mouseCentered = u_mouse - 0.5;\n    mouseCentered.x *= u_resolution.x / u_resolution.y;\n    vec2 dirToMouse = vec2(0.0);\n     if (length(uv - mouseCentered) >= 0.0001) { // Check against small epsilon\n        dirToMouse = normalize(uv - mouseCentered);\n    }\n    uv += dirToMouse * distortionMag * 0.1;\n\n\n    float time = u_time * BASE_SPEED * (1.0 + u_intensity * 0.5);\n    float angle = time * 0.5;\n    float scale = 1.0 + sin(time * 0.3) * 0.1 * (1.0 + u_intensity);\n\n    uv *= rotate2d(angle);\n    uv *= scale;\n\n    // --- 3. Pattern Generation (Concentric Circles & Noise) ---\n    float distFromCenter = length(uv);\n\n    float dynamicNoiseScale = NOISE_SCALE * (1.0 + u_intensity) * mix(1.0, 0.5, 1.0 - mouseFactor);\n    vec2 noiseCoord = uv * dynamicNoiseScale + vec2(time * 0.2, -time * 0.15);\n    float noiseVal = (sin(noiseCoord.x) * cos(noiseCoord.y)) * 0.5 + 0.5;\n\n    // Calculate parameters needed for the line pattern function\n    float circleFreq = CIRCLE_COUNT * (1.0 + u_intensity * 0.1);\n    float thickness = BASE_THICKNESS * mix(1.0, 0.5, u_intensity);\n    float lineSharpness = 0.005 / (1.0 + u_intensity);\n\n    // Calculate base lines (used for Green channel)\n    float lines = calculateLinePattern(uv, noiseVal, u_intensity, circleFreq, thickness, lineSharpness);\n\n\n    // --- 4. Chromatic Aberration ---\n    float aberrationStrength = COLOR_SHIFT_AMOUNT * (1.0 + u_intensity * 3.0) * mix(1.5, 0.5, mouseFactor);\n\n    vec2 offsetDir = vec2(1.0, 0.0); // Default offset direction\n    if (length(uv) >= 0.0001) { // Check against small epsilon\n        offsetDir = normalize(uv);\n    }\n\n    // Calculate R, G, B components using the new function\n    float r = calculateLinePattern(uv + offsetDir * aberrationStrength, noiseVal, u_intensity, circleFreq, thickness, lineSharpness);\n    float g = lines; // Reuse the already calculated lines for Green\n    float b = calculateLinePattern(uv - offsetDir * aberrationStrength, noiseVal, u_intensity, circleFreq, thickness, lineSharpness);\n\n\n    // --- 5. Color Composition ---\n    vec3 finalColor = COLOR_1 * (0.5 + noiseVal * 0.5);\n\n    float glowIntensity = 0.5 + u_intensity * 1.5;\n    finalColor += vec3(r, 0.0, 0.0) * COLOR_2 * glowIntensity;\n    finalColor += vec3(0.0, g, 0.0) * COLOR_2 * glowIntensity * 5.8;\n    finalColor += vec3(0.0, 0.0, b) * COLOR_3 * glowIntensity;\n\n    float mouseColorBoost = (1.0 - mouseFactor) * 0.3 * (1.0 + u_intensity);\n    finalColor *= (1.0 + mouseColorBoost);\n\n    // --- 6. Alpha / Transparency ---\n    float edgeFactor = smoothstep(0.4, 0.6, length(vUv - 0.5));\n    float baseAlpha = 0.8 - edgeFactor * 0.2;\n    float mouseAlphaFactor = (1.0 - mouseFactor) * 0.2;\n    float finalAlpha = clamp(baseAlpha + mouseAlphaFactor + u_intensity * 0.1, 0.1, 1.0);\n\n    // --- Final Output ---\n    gl_FragColor = vec4(finalColor, finalAlpha);\n}"
}