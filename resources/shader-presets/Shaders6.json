{
  "id": "Shaders6",
  "isDefault": false,
  "vertex": "// 无需版本声明，Three.js 会自动处理\n// 直接使用内置 attribute \"position\"\n\nvarying vec2 vUv; // 将 UV 坐标传递给片段着色器\n\nvoid main() {\n  // 将顶点坐标直接设置为裁剪空间坐标\n  gl_Position = vec4(position, 1.0);\n\n  // 计算并传递 UV 坐标\n  vUv = position.xy * 0.5 + 0.5;\n}",
  "fragment": "precision mediump float;\n\nuniform float u_time;       // 时间变量，用于动画\nuniform vec2  u_resolution; // 屏幕分辨率\nuniform vec2  u_mouse;      // 鼠标位置 (归一化到 [0, 1])\nuniform float u_intensity;  // 键盘影响强度 [0, 1]\n\nvarying vec2 vUv;           // 从顶点着色器传入的 UV 坐标\n\n#define PI 3.14159265359\n#define GRID_SCALE 8.0  // 网格密度\n#define ROTATION_ANGLE radians(15.0) // 基础倾斜角度\n#define GAP 0.1  // 方块之间的间隙比例\n\n// 简单伪随机数生成\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\n// 鼠标影响计算函数\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    return (1.0 - smoothstep(0.0, radius, dist)) * strength;\n}\n\n// 旋转矩阵\nmat2 rotate2D(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main() {\n    // 计算鼠标参数和强度\n    float mouseRadius = 0.4 + u_intensity * 0.2;\n    float mouseStrength = 0.8 + u_intensity * 0.5;\n    \n    // 动态时间因子（随时间缓慢变化）\n    float timeFactor = sin(u_time * 0.2) * 0.5 + 0.5;\n    \n    // --- 基本网格设置 ---\n    vec2 uv = vUv;\n    vec2 centeredUv = uv - 0.5;\n    \n    // 基础旋转\n    mat2 baseRotation = rotate2D(ROTATION_ANGLE);\n    vec2 rotatedUv = baseRotation * centeredUv + 0.5;\n    \n    // 网格计算\n    vec2 gridUv = rotatedUv * GRID_SCALE;\n    vec2 cellId = floor(gridUv);\n    vec2 cellUv = fract(gridUv);\n    \n    // 单元格中心位置\n    vec2 cellCenter = (cellId + 0.5) / GRID_SCALE;\n    vec2 originalCellCenter = (rotate2D(-ROTATION_ANGLE) * (cellCenter - 0.5)) + 0.5;\n    \n    // --- 鼠标和键盘交互 ---\n    float mouseFactor = mouseInfluence(originalCellCenter, u_mouse, mouseRadius, mouseStrength);\n    \n    // 生成每个单元格的随机值\n    float cellRandom = hash21(cellId);\n    float cellTime = u_time * (0.2 + cellRandom * 0.3) + cellRandom * 10.0;\n    \n    // --- 3D 变形和旋转 ---\n    // 基于方块位置、鼠标位置和随机值计算旋转角度\n    float xRotation = mouseFactor * PI * 0.5 * sin(cellTime * 0.3);\n    float yRotation = mouseFactor * PI * 0.5 * cos(cellTime * 0.4);\n    float zRotation = mouseFactor * PI * 0.25 * sin(cellTime * 0.5);\n    \n    // 应用形变到局部坐标系\n    vec2 transformedUv = cellUv - 0.5;\n    \n    // X轴旋转（挤压Y方向）\n    float scaleY = 1.0 - 0.5 * abs(sin(xRotation));\n    transformedUv.y *= scaleY;\n    \n    // Y轴旋转（挤压X方向）\n    float scaleX = 1.0 - 0.5 * abs(sin(yRotation));\n    transformedUv.x *= scaleX;\n    \n    // Z轴旋转（旋转XY平面）\n    transformedUv = rotate2D(zRotation) * transformedUv;\n    \n    // 添加u_intensity的影响\n    float intensityEffect = u_intensity * 0.2;\n    transformedUv *= 1.0 - intensityEffect + sin(cellTime) * intensityEffect;\n    \n    // 将变形后的坐标移回中心位置\n    transformedUv += 0.5;\n    \n    // --- 绘制正方形 ---\n    // 计算缩放后的间隙\n    float gapSize = GAP * (1.0 + mouseFactor * 0.5);\n    \n    // 检查是否在方块内部（考虑间隙）\n    bool insideSquare = \n        transformedUv.x >= gapSize && \n        transformedUv.x <= 1.0 - gapSize && \n        transformedUv.y >= gapSize && \n        transformedUv.y <= 1.0 - gapSize;\n    \n    // --- 颜色计算 ---\n    // 魔方颜色数组\n    vec3 colors[6];\n    colors[0] = vec3(0.8, 0.1, 0.1); // 红\n    colors[1] = vec3(0.1, 0.6, 0.2); // 绿\n    colors[2] = vec3(0.1, 0.3, 0.8); // 蓝\n    colors[3] = vec3(1.0, 0.5, 0.1); // 橙\n    colors[4] = vec3(1.0, 0.9, 0.2); // 黄\n    colors[5] = vec3(0.9, 0.9, 0.9); // 白\n    \n    // 根据单元格ID选择基础颜色\n    int colorIndex = int(mod(cellRandom * 6.0, 6.0));\n    vec3 baseColor = colors[colorIndex];\n    \n    // 模拟3D光照\n    float lightIntensity = 0.7 + 0.3 * (\n        sin(xRotation) * (transformedUv.y - 0.5) + \n        sin(yRotation) * (transformedUv.x - 0.5)\n    );\n    \n    // 亮度随鼠标和旋转变化\n    vec3 litColor = baseColor * lightIntensity;\n    \n    // 边缘高光\n    float edgeHighlight = smoothstep(gapSize, gapSize + 0.05, min(\n        min(transformedUv.x, 1.0 - transformedUv.x),\n        min(transformedUv.y, 1.0 - transformedUv.y)\n    ));\n    \n    // 最终颜色（方块内部和背景）\n    vec3 finalColor = insideSquare ? \n        mix(litColor * 1.3, litColor, edgeHighlight) : // 内部颜色带边缘高光\n        vec3(0.05); // 暗色背景\n    \n    // 应用最终颜色\n    gl_FragColor = vec4(finalColor, 1.0);\n}"
}