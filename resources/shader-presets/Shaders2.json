{
  "id": "Shaders2",
  "isDefault": false,
  "vertex": "// Three.js 会自动注入版本\n\n// 直接使用内置的 position 属性\nvoid main() {\n    // 全屏渲染，保持简单\n    gl_Position = vec4(position, 1.0);\n}",
  "fragment": "precision highp float;\n\nuniform float u_time;       // 动画时间\nuniform vec2 u_resolution;  // 屏幕分辨率\nuniform vec2 u_mouse;       // 鼠标坐标(0.0-1.0)\nuniform float u_intensity;  // 交互强度(基于键盘输入)\n\n// 为模拟银河系定义的颜色\nconst vec3 VOID_COLOR = vec3(0.01, 0.0, 0.03); // 黑洞中心颜色\nconst vec3 DUST_COLOR = vec3(0.4, 0.2, 0.5);   // 星云尘埃颜色\nconst vec3 ACCRETION_COLOR = vec3(0.7, 0.3, 0.0); // 吸积盘颜色\nconst vec3 HALO_COLOR = vec3(0.4, 0.6, 1.0);   // 黑洞光晕颜色\nconst vec3 STAR_COLOR = vec3(0.9, 0.9, 1.0);   // 星星颜色\n\n// 生成随机数\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// 生成分形布朗运动噪声(模拟星云质感)\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    float w = 0.5;\n    for (int i = 0; i < 5; i++) {\n        f += w * random(p);\n        p *= 2.0;\n        w *= 0.5;\n    }\n    return f;\n}\n\n// 鼠标影响计算函数\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    // 平滑过渡影响范围\n    return strength * (1.0 - smoothstep(0.0, radius, dist));\n}\n\n// 星星生成函数\nfloat stars(vec2 uv, float threshold) {\n    float noise = random(uv);\n    float star = step(threshold, noise);\n    \n    // 星星闪烁\n    float glow = sin(u_time * (noise * 5.0) + noise * 10.0) * 0.5 + 0.5;\n    return star * glow;\n}\n\nvoid main() {\n    // 标准化坐标，使(0,0)在屏幕中心\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);\n    vec2 uv01 = gl_FragCoord.xy / u_resolution.xy; // 0到1的标准化坐标\n    \n    // 计算黑洞中心\n    vec2 blackHoleCenter = vec2(0.0);\n    \n    // 计算鼠标影响参数\n    float mouseRadius = 0.4 + u_intensity * 0.3; // 鼠标影响半径随强度增加\n    float mouseStrength = 0.8 + u_intensity * 0.5; // 鼠标影响强度随强度增加\n    float mouseFactor = mouseInfluence(uv01, u_mouse, mouseRadius, mouseStrength);\n    \n    // 计算到黑洞中心的距离和方向\n    float dist = length(uv - blackHoleCenter);\n    vec2 direction = normalize(uv - blackHoleCenter);\n    \n    // 吸积力场计算（向中心吸引的物质流动）\n    float attractionForce = 0.4 + u_intensity * 0.3 + mouseFactor * 0.5; // 黑洞引力随强度和鼠标影响增加\n    float distortionRadius = 2.0 + u_intensity * 1.5; // 扭曲效果范围随强度增加\n    \n    // 扭曲UV坐标模拟物质被吸入黑洞的效果\n    float distortionFactor = 1.0 / (1.0 + dist * 0.2);\n    float rotationSpeed = u_time * (0.2 + u_intensity * 0.3);\n    \n    // 计算旋转矩阵\n    float s = sin(rotationSpeed);\n    float c = cos(rotationSpeed);\n    \n    // 扭曲UV坐标（螺旋方式），模拟物质被黑洞吸引\n    vec2 distortedUV = uv;\n    if (dist > 0.05) { // 防止中心区域过度扭曲\n        // 螺旋扭曲效果，随距离衰减\n        float spiralStrength = min(1.0, attractionForce / (dist * dist) * 0.1);\n        // 扭曲系数随鼠标影响增强\n        spiralStrength *= (1.0 + mouseFactor * 2.0);\n        \n        // 应用旋转和向心力扭曲\n        distortedUV = vec2(\n            uv.x * c - uv.y * s,\n            uv.x * s + uv.y * c\n        );\n        \n        // 向中心弯曲\n        distortedUV = mix(\n            uv,\n            normalize(distortedUV) * (dist - spiralStrength),\n            smoothstep(1.0, 0.0, dist) * attractionForce\n        );\n    }\n    \n    // 生成星云纹理\n    float noiseScale = 2.0 + u_intensity * 1.5; // 噪声缩放随强度增加\n    float starNebula = fbm(distortedUV * noiseScale + u_time * 0.1);\n    \n    // 黑洞事件视界（中心黑色区域）\n    float eventHorizon = 1.0 - smoothstep(0.0, 0.1 + u_intensity * 0.05, dist);\n    \n    // 吸积盘（围绕黑洞的物质）\n    float accretionDisk = smoothstep(0.1, 0.4, dist) * (1.0 - smoothstep(0.4, 0.8 + mouseFactor * 0.3, dist));\n    \n    // 光晕效果\n    float halo = 0.05 / (dist * dist + 0.05);\n    \n    // 星空背景\n    float starField = stars(uv * 10.0, 0.98); // 稀疏的星星\n    float starField2 = stars(uv * 20.0 + vec2(0.4), 0.992); // 更稀疏的星星\n    \n    // 颜色混合\n    vec3 color = VOID_COLOR; // 基础背景色\n    \n    // 添加星空\n    color += STAR_COLOR * (starField * 0.5 + starField2 * 0.3);\n    \n    // 添加黑洞吸积盘和星云\n    color = mix(color, DUST_COLOR, starNebula * accretionDisk * 0.7);\n    color = mix(color, ACCRETION_COLOR, accretionDisk * smoothstep(0.3, 0.5, starNebula) * (1.0 + u_intensity * 0.5));\n    \n    // 添加扭曲光晕\n    color += HALO_COLOR * halo * (0.2 + u_intensity * 0.4);\n    \n    // 黑洞中心吞噬效果（完全黑暗）\n    color = mix(color, VOID_COLOR, eventHorizon);\n    \n    // 鼠标影响效果（增加吸积盘亮度和扭曲）\n    if (mouseFactor > 0.05) {\n        // 鼠标位置产生额外光晕和物质波动\n        float mouseGlow = 0.02 / (pow(length(uv01 - u_mouse) * 2.0, 2.0) + 0.02);\n        color += ACCRETION_COLOR * mouseGlow * mouseFactor * 2.0;\n        \n        // 鼠标影响区域的星云颜色变化\n        color = mix(color, ACCRETION_COLOR * 1.5, mouseFactor * 0.3);\n    }\n    \n    // 最终强度调整\n    color = mix(color, color * 1.5, u_intensity * 0.4); // 整体亮度随强度增加\n    \n    gl_FragColor = vec4(color, 1.0);\n}"
}