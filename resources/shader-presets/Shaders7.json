{
  "id": "Shaders7",
  "isDefault": false,
  "vertex": "// 顶点着色器\n// 使用内置的position属性传递顶点位置\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv; // 传递UV坐标到片元着色器\n    gl_Position = vec4(position, 1.0);\n}",
  "fragment": "precision mediump float;\n\nuniform float u_time;       // 时间变量\nuniform vec2 u_mouse;       // 鼠标位置\nuniform vec2 u_resolution;  // 画布分辨率\nuniform float u_intensity;  // 强度参数 - 受键盘输入影响\nvarying vec2 vUv;           // 从顶点着色器传入的UV坐标\n\n// 噪声函数 - 产生基础随机模式\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // 平滑插值\n    \n    // 利用正弦函数生成伪随机值\n    float a = sin(i.x + i.y * 31.23 + u_time);\n    float b = sin(i.x + 1.0 + i.y * 31.23 + u_time);\n    float c = sin(i.x + (i.y + 1.0) * 31.23 + u_time);\n    float d = sin(i.x + 1.0 + (i.y + 1.0) * 31.23 + u_time);\n    \n    // 双线性插值混合四个角的值\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n// 分形布朗运动 - 叠加多层噪声创造复杂纹理\nfloat fbm(vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    \n    // 叠加6层不同频率和振幅的噪声\n    for(int i = 0; i < 6; i++) {\n        sum += noise(p * freq) * amp;\n        amp *= 0.5;     // 每层振幅减半\n        freq *= 2.0;    // 每层频率翻倍\n        p += vec2(3.123, 1.732); // 偏移避免重复模式\n    }\n    return sum;\n}\n\n// 鼠标影响计算函数 - 控制鼠标对效果的影响范围和强度\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    return (1.0 - smoothstep(0.0, radius, dist)) * strength;\n}\n\nvoid main() {\n    // 调整UV坐标以保持正确的宽高比\n    vec2 uv = vUv;\n    vec2 aspect = vec2(u_resolution.x/u_resolution.y, 1.0);\n    uv = uv * 2.0 - 1.0;\n    uv *= aspect;\n    \n    // 计算鼠标影响参数\n    float mouseRadius = 0.4 + u_intensity * 0.2;    // 鼠标影响半径随强度增加\n    float mouseStrength = 0.8 + u_intensity * 0.5;  // 鼠标影响强度随强度增加\n    vec2 mousePos = (u_mouse * 2.0 - 1.0) * aspect; // 调整鼠标坐标到正确空间\n    float mouseFactor = mouseInfluence(uv, mousePos, mouseRadius, mouseStrength);\n    \n    // 时间动画和移动效果\n    float t = u_time * (0.0002 + u_intensity * 0.0001);  // 时间流动速度随强度变化\n    vec2 movement = vec2(sin(t * 0.5), cos(t * 0.7));\n    \n    // 噪声缩放参数 - 受强度和鼠标影响调整\n    float noiseScale1 = 3.0 + u_intensity * 1.0 + mouseFactor * 0.5;\n    float noiseScale2 = 2.0 + u_intensity * 0.8 - mouseFactor * 0.3;\n    float noiseScale3 = 4.0 + u_intensity * 1.5 + mouseFactor * 0.7;\n    \n    // 计算三层噪声 - 互相影响形成复杂模式\n    float n1 = fbm(uv * noiseScale1 + movement + mouseFactor * 0.3);\n    float n2 = fbm(uv * noiseScale2 - movement - mouseFactor * 0.2);\n    float n3 = fbm(uv * noiseScale3 + vec2(n1, n2) * (1.0 + mouseFactor * 0.4));\n    \n    // 基础颜色定义\n    vec3 col1 = vec3(0.2, 0.5, 0.8); // 蓝色调\n    vec3 col2 = vec3(0.8, 0.2, 0.5); // 紫红色调\n    vec3 col3 = vec3(0.1, 0.8, 0.4); // 绿色调\n    \n    // 颜色混合 - 使用噪声和强度参数\n    vec3 finalColor = mix(col1, col2, n1);\n    finalColor = mix(finalColor, col3, n2 * (0.5 + u_intensity * 0.2));\n    finalColor += n3 * (0.2 + u_intensity * 0.1);\n    \n    // 鼠标悬停高亮效果\n    finalColor += vec3(mouseFactor * 0.2);\n    \n    // 最终颜色调整 - 使用强度参数增强对比度\n    finalColor = mix(finalColor, finalColor * 1.3, u_intensity * 0.3);\n    \n    // 输出最终颜色\n    gl_FragColor = vec4(finalColor, 1.0);\n}"
}