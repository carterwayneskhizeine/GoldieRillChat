{
  "id": "Shaders4",
  "isDefault": false,
  "vertex": "uniform float u_time;\nuniform vec2 u_mouse;\nuniform float u_intensity;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    \n    // Pass position directly to gl_Position\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectedPosition = projectionMatrix * viewPosition;\n    \n    gl_Position = projectedPosition;\n}",
  "fragment": "uniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_intensity;\n\nvarying vec2 vUv;\n\n// Mouse influence calculation function\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    return 1.0 - smoothstep(0.0, radius, dist) * strength;\n}\n\n// Psychedelic patterns generator\nvec3 psyPattern(vec2 uv, float time, float distortion) {\n    // Create multiple interfering sine waves for psychedelic patterns\n    float x = uv.x * 10.0;\n    float y = uv.y * 10.0;\n    \n    // Rotate coordinates over time\n    float angle = time * 0.2;\n    vec2 rotatedUv = vec2(\n        x * cos(angle) - y * sin(angle),\n        y * cos(angle) + x * sin(angle)\n    );\n    \n    // Generate interfering patterns\n    float pattern1 = sin(rotatedUv.x * 0.5 + time) * sin(rotatedUv.y * 0.5 + time * 0.7);\n    float pattern2 = sin(rotatedUv.x * 1.2 + time * 1.1) * sin(rotatedUv.y * 1.2 + time * 0.9);\n    float pattern3 = sin(rotatedUv.x * 2.3 + time * 0.7) * sin(rotatedUv.y * 2.3 + time * 1.3);\n    \n    // Mix patterns with distortion\n    float finalPattern = pattern1 * 0.5 + pattern2 * 0.3 + pattern3 * 0.2;\n    finalPattern = finalPattern * (1.0 + distortion);\n    \n    // Create psychedelic colors\n    vec3 col1 = vec3(0.5 + 0.5 * sin(time), 0.5 + 0.5 * cos(time * 0.7), 0.5 + 0.5 * sin(time * 0.3));\n    vec3 col2 = vec3(0.5 + 0.5 * cos(time * 0.8), 0.5 + 0.5 * sin(time * 0.5), 0.5 + 0.5 * cos(time * 0.9));\n    vec3 col3 = vec3(1.0, 0.2, 0.8) * (0.5 + 0.5 * sin(time * 0.4)); \n    \n    // Mix colors based on pattern\n    return mix(\n        mix(col1, col2, finalPattern + 0.5),\n        col3,\n        sin(finalPattern * 3.14159 + time) * 0.5 + 0.5\n    );\n}\n\n// Ripple distortion function\nvec2 rippleEffect(vec2 uv, vec2 center, float time, float frequency, float amplitude) {\n    float dist = distance(uv, center);\n    float ripple = sin(dist * frequency - time) * amplitude / dist;\n    return vec2(ripple * (uv.x - center.x), ripple * (uv.y - center.y));\n}\n\nvoid main() {\n    // Calculate mouse influence parameters\n    float mouseRadius = 0.4 + u_intensity * 0.2;\n    float mouseStrength = 0.8 + u_intensity * 0.5;\n    float mouseFactor = mouseInfluence(vUv, u_mouse, mouseRadius, mouseStrength);\n    \n    // Create multiple ripple centers\n    vec2 rippleCenter1 = u_mouse;\n    vec2 rippleCenter2 = vec2(0.5 + 0.3 * sin(u_time * 0.3), 0.5 + 0.3 * cos(u_time * 0.4));\n    vec2 rippleCenter3 = vec2(0.5 + 0.4 * cos(u_time * 0.5), 0.5 + 0.4 * sin(u_time * 0.6));\n    \n    // Apply ripple distortions to UV coordinates\n    vec2 distortedUV = vUv;\n    \n    // Frequency and amplitude affected by mouse and intensity\n    float freq1 = 15.0 + mouseFactor * 10.0 + u_intensity * 5.0;\n    float freq2 = 12.0 - mouseFactor * 5.0 + u_intensity * 3.0;\n    float freq3 = 20.0 + sin(u_time) * 5.0 + u_intensity * 7.0;\n    \n    float amp1 = 0.03 + mouseFactor * 0.05 + u_intensity * 0.02;\n    float amp2 = 0.02 + mouseFactor * 0.03 + u_intensity * 0.03;\n    float amp3 = 0.04 + sin(u_time * 0.5) * 0.02 + u_intensity * 0.04;\n    \n    // Apply multiple overlapping ripples\n    distortedUV += rippleEffect(vUv, rippleCenter1, u_time * 2.0, freq1, amp1);\n    distortedUV += rippleEffect(vUv, rippleCenter2, u_time * 1.7, freq2, amp2);\n    distortedUV += rippleEffect(vUv, rippleCenter3, u_time * 2.3, freq3, amp3);\n    \n    // Extra distortions\n    float noiseScale = 3.0 + mouseFactor * 4.0 + u_intensity * 3.0;\n    distortedUV.x += sin(distortedUV.y * noiseScale + u_time) * 0.02;\n    distortedUV.y += cos(distortedUV.x * noiseScale + u_time * 0.7) * 0.02;\n    \n    // Generate psychedelic pattern\n    vec3 color = psyPattern(distortedUV, u_time, mouseFactor * 1.5 + u_intensity * 0.8);\n    \n    // Add extra color pulse with mouse interaction\n    color = mix(\n        color,\n        vec3(sin(u_time) * 0.5 + 0.5, cos(u_time * 0.7) * 0.5 + 0.5, sin(u_time * 0.3) * 0.5 + 0.5),\n        mouseFactor * 0.3\n    );\n    \n    // Add electric edges along ripple boundaries\n    float edgePulse = sin(distance(vUv, u_mouse) * 30.0 - u_time * 5.0);\n    float edgeIntensity = pow(abs(edgePulse), 5.0) * mouseFactor;\n    vec3 edgeColor = vec3(1.0, 0.3 + sin(u_time) * 0.3, 0.9 + cos(u_time * 0.5) * 0.3);\n    color = mix(color, edgeColor, edgeIntensity * 0.5);\n    \n    // Enhance saturation with intensity\n    float saturationBoost = 1.0 + u_intensity * 0.3 + mouseFactor * 0.2;\n    vec3 grayScale = vec3(dot(color, vec3(0.299, 0.587, 0.114)));\n    color = mix(grayScale, color, saturationBoost);\n    \n    // Calculate alpha/transparency with psychedelic pulsing\n    float alpha = 0.7 + 0.15 * sin(u_time + distortedUV.y * 3.0) + u_intensity * 0.15;\n    \n    // Output final color\n    gl_FragColor = vec4(color, alpha);\n}\n"
}