{
  "id": "Shaders10",
  "isDefault": false,
  "vertex": "// Three.js 会自动注入版本声明，此处无需添加\n// 直接使用内置的 position 属性，无需声明\n// 这个顶点着色器非常基础，仅将顶点位置传递给渲染管线\nvoid main() {\n    // gl_Position 是一个内置变量，用于存储最终的顶点位置 (裁剪空间坐标)\n    // 我们直接使用模型的原始位置，并将其 w 分量设为 1.0\n    gl_Position = vec4(position, 1.0);\n}",
  "fragment": "// 设置浮点数精度为中等，平衡性能和质量\nprecision mediump float;\n\n// Uniforms 由 Three.js 传入\nuniform float u_time;       // 时间，用于动画\nuniform vec2  u_resolution; // 画布的分辨率 (width, height)\nuniform vec2  u_mouse;      // 鼠标位置 (归一化到 0.0 - 1.0)\nuniform float u_intensity;  // 键盘控制的强度值 (通常在 0.0 到 1.0 之间)\n\n// --- 工具函数 ---\n\n// SDF: 圆形\n// p: 当前点坐标, center: 圆心, r: 半径\n// 返回点 p 到圆周的最短距离 (负数表示在圆内)\nfloat sdCircle(vec2 p, vec2 center, float r) {\n    return length(p - center) - r;\n}\n\n// 2D 旋转矩阵\nmat2 rotate2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// 鼠标影响计算函数\n// uv: 当前片元坐标, mouse: 鼠标坐标, radius: 影响半径, strength: 影响强度\n// 返回一个基于距离的权重因子 (0.0 到 strength)\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    // 使用 smoothstep 在 radius*0.5 到 radius 范围内创建平滑过渡\n    // 当 dist < radius*0.5 时，值为 strength\n    // 当 dist > radius 时，值为 0.0\n    return smoothstep(radius, radius * 0.5, dist) * strength;\n}\n\n// --- 主函数 ---\nvoid main() {\n    // 1. 坐标标准化与居中\n    // 将屏幕坐标 (0,0) -> (width, height) 转换为 (-aspect, -1) -> (aspect, 1) 或 (-1, -1/aspect) -> (1, 1/aspect)\n    // 使坐标中心在 (0,0)，并保持正确的宽高比\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution) / min(u_resolution.x, u_resolution.y);\n    // 将鼠标坐标也映射到 [-1, 1] 的近似范围 (忽略宽高比修正，通常影响不大)\n    vec2 mouse = u_mouse * 2.0 - 1.0;\n\n    // 2. 计算鼠标影响\n    float mouseRadius = 0.4 + u_intensity * 0.3;  // 鼠标影响半径，受键盘强度影响，范围约为 0.4 - 0.7\n    float mouseStrength = 0.5 + u_intensity * 0.8; // 鼠标影响强度，受键盘强度影响，范围约为 0.5 - 1.3\n    float mouseFactor = mouseInfluence(uv, mouse, mouseRadius, mouseStrength); // 计算当前片元受鼠标影响的程度\n\n    // 3. 坐标扭曲 (核心：改变形状)\n    vec2 distortedUV = uv; // 从原始 UV 开始\n    if (mouseFactor > 0.0) { // 只在影响范围内进行扭曲\n        // 计算从鼠标指向当前点的方向\n        vec2 direction = normalize(uv - mouse);\n        // 扭曲的幅度，受 mouseFactor 和 u_intensity 控制\n        // 添加一个随时间变化的波浪效果，增加动态感\n        float distortionAmount = mouseFactor * (0.15 + u_intensity * 0.2) * (1.0 + sin(distance(uv, mouse) * 15.0 - u_time * 3.0) * 0.5);\n        // 将 UV 沿着方向进行偏移，实现扭曲\n        distortedUV = uv + direction * distortionAmount;\n    }\n\n    // 4. 使用扭曲后的坐标进行图案绘制\n    vec3 color = vec3(0.0); // 背景色：深邃的颜色\n    vec2 p = distortedUV;\n\n    // 添加整体旋转动画，受强度影响旋转速度\n    p *= rotate2d(u_time * 0.05 + u_intensity * 0.1);\n\n    // 绘制多个动态变化的圆环/圆点\n    float d = 1.0; // 初始化一个距离值\n    int numCircles = 9 + int(u_intensity * 9.0); // 圆的数量受强度影响 (3 到 8 个)\n\n    for (int i = 0; i < numCircles; i++) {\n        float fi = float(i);\n        // 圆心随时间在特定轨道上移动\n        float orbitRadius = 0.3 + fi * 0.05 + u_intensity * 0.1; // 轨道半径\n        float angle = u_time * (0.2 + fi * 0.03) + fi * 1.57; // 旋转角度\n        vec2 center = vec2(cos(angle), sin(angle)) * orbitRadius;\n\n        // 圆的半径也随时间变化\n        float circleRadius = 0.03 + sin(u_time * 0.5 + fi * 2.0) * (0.01 + u_intensity * 0.02);\n\n        // 计算当前点到这个圆的 SDF 距离\n        float currentDist = sdCircle(p, center, circleRadius);\n\n        // 使用取最小值的方式混合多个 SDF，形成融合效果\n        d = min(d, abs(currentDist)); // 使用 abs(currentDist) 绘制细线圆环，而不是实心圆\n        // 如果想绘制实心圆，用 d = min(d, currentDist);\n    }\n\n    // 5. 根据 SDF 距离计算颜色\n    // 创建一个发光效果，距离圆环越近，颜色越亮\n    // glowWidth 控制光晕的宽度，受强度影响\n    float glowWidth = 0.005 + u_intensity * 0.01;\n    float glow = smoothstep(glowWidth, 0.0, d); // 距离 d 越小，glow 越接近 1\n\n    // 定义形状的基础颜色\n    vec3 shapeColor = vec3(0.702, 0.502, 0.027); // 偏紫色的光晕\n    // 基础背景色\n    vec3 baseColor = vec3(0.05, 0.02, 0.1); // 深蓝紫色\n\n    // 混合背景色和光晕色\n    color = mix(baseColor, shapeColor, glow);\n\n    // 也可以添加一些微弱的、不受扭曲影响的背景细节\n    // color += sin(uv.x * 30.0) * 0.01; // 非常微弱的竖条纹\n\n    // 输出最终颜色\n    gl_FragColor = vec4(color, 1.0); // Alpha 设为 1.0 (不透明)\n}"
}