{
  "id": "Shaders3",
  "isDefault": false,
  "vertex": "// Vertex Shader: 将顶点位置和 UV 坐标传递给片段着色器\n// 无需版本声明，Three.js 会自动注入\n// 直接使用内置 attribute \"position\"\n\nvarying vec2 vUv; // 将 UV 坐标传递给 Fragment Shader\n\nvoid main() {\n  // 将标准化设备坐标 (-1 到 1) 转换为 UV 坐标 (0 到 1)\n  vUv = position.xy * 0.5 + 0.5;\n  // 设置顶点位置，对于全屏背景，通常直接使用 position\n  gl_Position = vec4(position, 1.0);\n}",
  "fragment": "precision mediump float;\n\nuniform float u_time;       // 时间，用于动画\nuniform vec2  u_resolution; // 屏幕分辨率\nuniform vec2  u_mouse;      // 鼠标位置 (0.0 to 1.0)\nuniform float u_intensity;  // 外部控制强度 (例如键盘输入, 0.0 to 1.0)\n\nvarying vec2 vUv; // 从 Vertex Shader 接收的 UV 坐标\n\n// 2D 随机数生成函数\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// 鼠标影响计算函数\n// 返回值: 影响因子 (鼠标中心接近 0.0, 半径外为 1.0)\nfloat mouseInfluenceFactor(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    // strength 控制影响程度，值为 1.0 时中心完全受影响\n    // 确保 strength 不会小于 0\n    strength = max(0.0, strength);\n    return 1.0 - smoothstep(0.0, radius, dist) * strength;\n}\n\n// Voronoi/Worley noise function\nvec3 voronoi(vec2 x, float time, float gridScale) {\n    vec2 n = floor(x * gridScale);\n    vec2 f = fract(x * gridScale);\n\n    vec3 m = vec3(8.0);\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(time + 6.2831 * o); // 点的动画\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d < m.x) {\n                m.y = m.x; m.x = d;\n            } else if (d < m.y) {\n                m.y = d;\n            }\n        }\n    }\n    return vec3(sqrt(m.x), sqrt(m.y), m.z);\n}\n\nvoid main() {\n    vec2 uv = vUv;\n\n    // --- 鼠标影响计算 ---\n    // mouseRadius: 鼠标影响半径，受 u_intensity 影响\n    float mouseRadius = 0.18 + u_intensity * 0.22;\n    // mouseStrength: 鼠标影响强度 (用于暗化和变形), 修正为正值\n    float mouseStrength = 0.95 + u_intensity * 0.05; // 强度较高，使影响明显\n    // mouseFactor: 鼠标影响因子 (中心接近0, 边缘为1)\n    float mouseFactor = mouseInfluenceFactor(uv, u_mouse, mouseRadius, mouseStrength);\n\n    // --- UV 变形 (Shape Transformation near Mouse) ---\n    // distortionStrength: 变形强度，在鼠标中心最强，受 u_intensity 影响\n    // 使用 (1.0 - mouseFactor) 使鼠标中心变形最强\n    float distortionStrength = (1.0 - mouseFactor) * (0.1 + u_intensity * 0.2);\n    vec2 directionToMouse = normalize(u_mouse - uv);\n    // 防止除零错误\n    if (length(u_mouse - uv) < 0.0001) {\n        directionToMouse = vec2(0.0, 1.0);\n    }\n    // 将 UV 推离鼠标中心，制造挤压/膨胀效果\n    vec2 distortedUV = uv + directionToMouse * distortionStrength;\n\n    // --- 效果参数 ---\n    // gridScale: Voronoi 网格密度，受 u_intensity 影响\n    float gridScale = 5.0 + u_intensity * 7.0; // 网格密度\n    // timeFactor: 动画速度，受 u_intensity 影响\n    float timeFactor = u_time * (0.08 + u_intensity * 0.12); // 动画速度\n\n    // --- Voronoi 计算 (使用变形后的 UV) ---\n    vec3 vor = voronoi(distortedUV, timeFactor, gridScale);\n\n    // --- 视觉元素 (暗背景，亮线条/点) ---\n    // dist1: 到最近点的距离\n    float dist1 = vor.x;\n    // dist2: 到第二近点的距离\n    float dist2 = vor.y;\n\n    // 1. 面 (Cells): 基础设为暗色 (黑色)\n    vec3 cellColor = vec3(0.0); // 背景色 (黑色)\n\n    // 2. 线 (Edges): 计算亮色线条 (白色)\n    float edgeSharpness = 0.004 + u_intensity * 0.006; // 线条锐度/粗细 (可以调小一点)\n    float edgeSoftness = 0.015 + u_intensity * 0.020;  // 线条羽化范围 (可以调小一点)\n    // 'linesFactor': 在线条处接近 1，远离线条处接近 0\n    float linesFactor = 1.0 - smoothstep(edgeSharpness, edgeSoftness, dist2 - dist1);\n    vec3 lineColor = vec3(1.0); // 线条颜色 (白色)\n\n    // 3. 点 (Sites): 计算亮色点 (白色)\n    float pointSize = 0.008 + u_intensity * 0.006; // 点的大小\n    // 'pointsFactor': 在点中心处接近 1，远离点处接近 0\n    float pointsFactor = smoothstep(pointSize, 0.0, dist1);\n    vec3 pointColor = vec3(1.0); // 点的颜色 (白色)\n\n    // --- 颜色混合 (从暗背景开始，叠加亮元素) ---\n    // 基础是暗色背景\n    vec3 patternColor = cellColor;\n    // 混合入亮色线条 (linesFactor 接近 1 的地方使用 lineColor)\n    patternColor = mix(patternColor, lineColor, linesFactor);\n    // 混合入亮色点 (pointsFactor 接近 1 的地方使用 pointColor)\n    // 注意：如果希望点覆盖在线条上，就用上面的结果继续 mix\n    patternColor = mix(patternColor, pointColor, pointsFactor);\n    // 如果希望点和线是独立的（点只在背景上显示），则：\n    // patternColor = mix(cellColor, lineColor, linesFactor);\n    // patternColor = mix(patternColor, pointColor, pointsFactor); // 这样点可能被线覆盖\n\n    // --- 应用鼠标影响 (使鼠标区域变暗) ---\n    // mouseFactor 在鼠标中心接近 0，远离时接近 1\n    // 将最终图案颜色乘以 mouseFactor 即可使鼠标区域的亮部(线条/点)变暗\n    // mix(minBrightness, 1.0, mouseFactor) 控制最暗处的亮度下限\n    float minBrightness = 0.1; // 鼠标中心的最暗亮度 (不是全黑，保留一点可见性)\n    vec3 finalColor = patternColor * mix(minBrightness, 1.0, mouseFactor);\n\n    // --- 输出最终颜色 ---\n    gl_FragColor = vec4(finalColor, 1.0);\n}"
}