{
  "id": "Shaders1",
  "isDefault": true,
  "vertex": "\n// Vertex Shader: 传递顶点位置和 UV 坐标\n// 无需版本声明，Three.js 会自动注入\n\nvarying vec2 vUv; // 将 UV 坐标传递给 Fragment Shader\n\nvoid main() {  \n  // 直接使用内置的 attribute \"position\" 和 \"uv\" (由 PlaneGeometry 提供)\n  vUv = uv; // 传递 UV 坐标\n  // gl_Position 是屏幕空间的最终位置\n  // 对于全屏背景，通常直接使用原始顶点位置\n  gl_Position = vec4(position, 1.0);\n}\n",
  "fragment": "\nprecision mediump float; // 设置浮点数精度\n\n// Uniforms: 由 Three.js 传入的变量\nuniform float u_time;       // 动画时间 (秒)\nuniform vec2  u_resolution; // 画布分辨率 (像素)\nuniform vec2  u_mouse;      // 鼠标位置 (归一化到 [0, 1])\nuniform float u_intensity;  // 控制效果强度的值 [0, 1]\n\n// Varyings: 从 Vertex Shader 传入的变量\nvarying vec2 vUv; // 插值后的 UV 坐标 [0, 1]\n\n// --- 常量和参数调整 ---\nconst float GRID_SCALE = 12.0;        // 网格密度，值越大网格越密\nconst float LINE_THICKNESS = 0.04;   // 网格线相对粗细 (相对于单元格大小)\nconst vec3 COLOR_BG = vec3(0.05, 0.0, 0.1); // 背景基础色 (深紫)\nconst vec3 COLOR_LINE = vec3(0.702, 0.502, 0.027); // 网格线基础色 (亮紫粉) - 也用于鼠标圆环\nconst vec3 COLOR_DOT = vec3(0.702, 0.502, 0.027);  // 交叉点基础色 (青色)\n// const vec3 COLOR_MOUSE = vec3(1.0, 1.0, 0.0); // 不再需要黄色高亮\nconst float DOT_SIZE = 0.1;         // 交叉点基础大小\nconst float ANIMATION_SPEED = 0.1;   // 整体动画速度倍率\nconst float MOUSE_RING_THICKNESS = 0.001; // 鼠标圆环线框的粗细 (UV 单位)\nconst float MOUSE_RING_SMOOTHNESS = 0.001; // 圆环边缘平滑过渡的宽度\n\n// --- 辅助函数 ---\n\n// 2D 旋转函数\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\n// 简单的伪随机数生成 (基于输入 vec2)\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// 鼠标影响计算函数 (现在主要用于变形和透明度)\n// uv: 当前片元 UV\n// mouse: 鼠标 UV\n// radius: 影响半径\n// strength: 影响强度 (最大影响程度)\n// 返回值: [0, 1]，0 表示在鼠标中心，1 表示在半径外\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    // smoothstep 在 [radius * (1.0 - strength), radius] 范围内从 1 平滑过渡到 0\n    return smoothstep(radius * (1.0 - strength), radius, dist);\n}\n\n// 创建平滑圆环遮罩的函数\n// dist: 到圆心的距离\n// radius: 圆环的外半径\n// thickness: 圆环的厚度\n// smoothness: 边缘平滑度\n// 返回值: [0, 1], 在环内为 1, 环外为 0, 边缘平滑过渡\nfloat smoothRingMask(float dist, float radius, float thickness, float smoothness) {\n    float innerRadius = radius - thickness;\n    // 计算内边缘 (从 0 平滑到 1)\n    float inner = smoothstep(innerRadius - smoothness, innerRadius, dist);\n    // 计算外边缘 (从 1 平滑到 0)\n    float outer = smoothstep(radius + smoothness, radius, dist);\n    return inner * outer; // 两者相乘得到环状遮罩\n}\n\n\n// --- 主函数 ---\nvoid main() {\n    // --- 1. 鼠标交互参数计算 ---\n    // 鼠标影响半径，受 u_intensity 影响 (用于变形、透明度和圆环定位)\n    float mouseRadius = 0.12 + u_intensity * 0.3; // 基础 0.2，最大 0.5\n    // 鼠标影响强度，受 u_intensity 影响 (主要用于变形)\n    float mouseStrength = 0.6 + u_intensity * 0.4; // 基础 0.6，最大 1.0\n    // 计算鼠标影响因子 (用于变形和透明度)，值越小表示离鼠标越近\n    // 使用原始 vUv 计算距离，使变形效果更可预测\n    float mouseFactor = mouseInfluence(vUv, u_mouse, mouseRadius, mouseStrength);\n\n    // --- 2. UV 处理与变形 ---\n    vec2 uv = vUv; // 从原始 vUv 开始\n\n    // 鼠标附近 UV 轻微扭曲效果：将 UV 推离鼠标中心\n    float mouseDistortionStrength = (1.0 - mouseFactor) * (0.1 + u_intensity * 0.1);\n    // 仅当距离大于一个小阈值时才应用变形，避免中心奇点\n    if (distance(vUv, u_mouse) > 0.001) {\n       uv += normalize(vUv - u_mouse) * mouseDistortionStrength;\n    }\n\n\n    // 添加基于时间的全局旋转和缩放，制造动态感\n    float timeScaled = u_time * ANIMATION_SPEED;\n    float angle = timeScaled * 0.2; // 缓慢旋转\n    float scale = 1.0 + sin(timeScaled * 0.3) * 0.05; // 轻微缩放脉动\n\n    // 将 UV 中心移到 (0,0)，应用旋转和缩放，再移回\n    uv = (uv - 0.5) * rotate2d(angle) * scale + 0.5;\n\n    // --- 3. 网格计算 ---\n    // 根据 u_intensity 调整网格密度\n    float dynamicGridScale = GRID_SCALE * (1.0 + u_intensity * 0.5);\n    vec2 gridUv = uv * dynamicGridScale;\n    vec2 fractGrid = fract(gridUv);\n    vec2 cellId = floor(gridUv);\n\n    // 计算到网格线的距离\n    float distToLineX = min(fractGrid.x, 1.0 - fractGrid.x);\n    float distToLineY = min(fractGrid.y, 1.0 - fractGrid.y);\n\n    // 使用 smoothstep 创建平滑的网格线\n    float lineThicknessAdj = LINE_THICKNESS * (0.5 + u_intensity * 0.5);\n    float lineX = smoothstep(0.0, lineThicknessAdj, distToLineX);\n    float lineY = smoothstep(0.0, lineThicknessAdj, distToLineY);\n    float gridMask = 1.0 - min(lineX, lineY); // 线条为 1，内部为 0\n\n    // --- 4. 交叉点计算 ---\n    float distToCenter = distance(fractGrid, vec2(0.5));\n    float dotSizeAdj = DOT_SIZE * (0.5 + 0.5 * sin(timeScaled * 2.0 + cellId.x * 0.5 + cellId.y * 0.3) + u_intensity * 0.5);\n    dotSizeAdj *= (0.8 + random(cellId) * 0.4);\n    float dotMask = 1.0 - smoothstep(0.0, dotSizeAdj, distToCenter); // 圆点区域为 1\n\n    // --- 5. 鼠标圆环计算 ---\n    // 计算当前原始 UV 到鼠标的距离，以获得稳定的圆环\n    float distToMouse = distance(vUv, u_mouse);\n    // 使用辅助函数创建圆环遮罩\n    // 圆环半径与 mouseRadius 一致，厚度和边缘平滑度由常量定义\n    float mouseRingMask = smoothRingMask(distToMouse, mouseRadius, MOUSE_RING_THICKNESS, MOUSE_RING_SMOOTHNESS);\n\n    // --- 6. 颜色混合 ---\n    // 基础背景色\n    vec3 finalColor = COLOR_BG;\n\n    // 混合网格线颜色，亮度受 intensity 影响\n    vec3 dynamicLineColor = COLOR_LINE * (0.7 + u_intensity * 0.6);\n    finalColor = mix(finalColor, dynamicLineColor, gridMask);\n\n    // 混合交叉点颜色，亮度也受 intensity 影响\n    vec3 dynamicDotColor = COLOR_DOT * (0.7 + u_intensity * 0.6);\n    finalColor = mix(finalColor, dynamicDotColor, dotMask * (1.0 - gridMask)); // 仅在非线条区域显示圆点\n\n    // 混合鼠标圆环效果 (替换原来的黄色高亮)\n    // 使用与网格线类似的颜色逻辑\n    vec3 mouseRingColor = COLOR_LINE * (0.8 + u_intensity * 0.4); // 圆环颜色和亮度\n    // 使用 mouseRingMask 进行混合，圆环会叠加在背景、网格线和点之上\n    finalColor = mix(finalColor, mouseRingColor, mouseRingMask);\n\n    // --- 7. 透明度计算 ---\n    float baseAlpha = 0.7;\n    float timeAlphaFactor = 0.1 * sin(timeScaled + vUv.y * 5.0); // 使用原始 vUv\n    // 鼠标附近透明度变化 (使用 mouseFactor)\n    float mouseAlphaFactor = (1.0 - mouseFactor) * 0.1; // 鼠标附近略微更不透明 (减小影响范围)\n    float finalAlpha = baseAlpha + timeAlphaFactor + mouseAlphaFactor + u_intensity * 0.1;\n    finalAlpha = clamp(finalAlpha, 0.1, 1.0);\n\n    // --- 输出最终颜色 ---\n    gl_FragColor = vec4(finalColor, finalAlpha);\n}  \n"
}