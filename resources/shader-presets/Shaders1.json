{
  "id": "Shaders1",
  "isDefault": true,
  "vertex": "\nprecision mediump float; // 设置浮点数精度\n\n// Uniforms: 由 Three.js 传入的变量\nuniform float u_time;       // 动画时间 (秒)\nuniform vec2  u_resolution; // 画布分辨率 (像素)\nuniform vec2  u_mouse;      // 鼠标位置 (归一化到 [0, 1])\nuniform float u_intensity;  // 控制效果强度的值 [0, 1]\n\n// Varyings: 从 Vertex Shader 传入的变量\nvarying vec2 vUv; // 插值后的 UV 坐标 [0, 1]\n\n// --- 常量和参数调整 ---\nconst float GRID_SCALE = 12.0;        // 网格密度，值越大网格越密\nconst float LINE_THICKNESS = 0.04;   // 网格线相对粗细 (相对于单元格大小)\nconst vec3 COLOR_BG = vec3(0.05, 0.0, 0.1); // 背景基础色 (深紫)\nconst vec3 COLOR_LINE = vec3(0.702, 0.502, 0.027); // 网格线基础色 (亮紫粉) - 也用于鼠标圆环\nconst vec3 COLOR_DOT = vec3(0.702, 0.502, 0.027);  // 交叉点基础色 (青色)\nconst float DOT_SIZE = 0.1;         // 交叉点基础大小\nconst float ANIMATION_SPEED = 0.1;   // 整体动画速度倍率\nconst float MOUSE_RING_THICKNESS = 0.001; // 鼠标圆环线框的粗细 (UV 单位)\nconst float MOUSE_RING_SMOOTHNESS = 0.001; // 圆环边缘平滑过渡的宽度\n\n// --- 辅助函数 ---\n\n// 2D 旋转函数\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\n// 简单的伪随机数生成 (基于输入 vec2)\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// 鼠标影响计算函数 (现在主要用于变形和透明度)\n// uv: 当前片元 UV (期望是原始屏幕比例 vUv)\n// mouse: 鼠标 UV\n// radius: 影响半径\n// strength: 影响强度 (最大影响程度)\n// 返回值: [0, 1]，0 表示在鼠标中心，1 表示在半径外\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    // !!! 使用 distance(uv, mouse) 计算圆形距离 !!!\n    float dist = distance(uv, mouse);\n    // smoothstep 在 [radius * (1.0 - strength), radius] 范围内从 1 平滑过渡到 0\n    return smoothstep(radius * (1.0 - strength), radius, dist);\n}\n\n// 创建平滑圆环遮罩的函数\n// dist: 到圆心的距离 (期望是基于原始屏幕比例 vUv 计算的距离)\n// radius: 圆环的外半径\n// thickness: 圆环的厚度\n// smoothness: 边缘平滑度\n// 返回值: [0, 1], 在环内为 1, 环外为 0, 边缘平滑过渡\nfloat smoothRingMask(float dist, float radius, float thickness, float smoothness) {\n    float innerRadius = radius - thickness;\n    float inner = smoothstep(innerRadius - smoothness, innerRadius, dist);\n    float outer = smoothstep(radius + smoothness, radius, dist);\n    return inner * outer;\n}\n\n\n// --- 主函数 ---\nvoid main() {\n    // --- 1. 鼠标交互参数计算 ---\n    float mouseRadius = 0.12 + u_intensity * 0.3;\n    float mouseStrength = 0.6 + u_intensity * 0.4;\n    // !!! 使用 vUv 计算 mouseFactor，确保影响区域是圆形的 !!!\n    float mouseFactor = mouseInfluence(vUv, u_mouse, mouseRadius, mouseStrength);\n\n    // --- 2. UV 处理与变形 ---\n    vec2 uv = vUv; // 从原始 vUv 开始\n\n    // 鼠标附近 UV 轻微扭曲效果 (基于圆形 mouseFactor 和 vUv 距离)\n    float mouseDistortionStrength = (1.0 - mouseFactor) * (0.1 + u_intensity * 0.1);\n    if (distance(vUv, u_mouse) > 0.001) {\n       // 方向基于 vUv，强度基于圆形 mouseFactor\n       uv += normalize(vUv - u_mouse) * mouseDistortionStrength;\n    }\n\n    // === 处理屏幕宽高比 (仅用于后续的空间计算如网格、旋转) ===\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    vec2 spatialUV = uv; // 使用可能已被鼠标扭曲的 uv 作为基础\n    spatialUV.x *= aspectRatio; // 校正 X 轴\n\n    // 时间相关的全局旋转和缩放 (作用在 spatialUV 上)\n    float timeScaled = u_time * ANIMATION_SPEED;\n    float angle = timeScaled * 0.2;\n    float scale = 1.0 + sin(timeScaled * 0.3) * 0.05;\n    vec2 centerOffset = vec2(0.5 * aspectRatio, 0.5);\n    spatialUV = (spatialUV - centerOffset) * rotate2d(angle) * scale + centerOffset;\n\n    // --- 3. 网格计算 ---\n    // (基于 spatialUV，所以网格本身会适应宽高比)\n    float dynamicGridScale = GRID_SCALE * (1.0 + u_intensity * 0.5);\n    vec2 gridUv = spatialUV * dynamicGridScale;\n    vec2 fractGrid = fract(gridUv);\n    vec2 cellId = floor(gridUv);\n    float distToLineX = min(fractGrid.x, 1.0 - fractGrid.x);\n    float distToLineY = min(fractGrid.y, 1.0 - fractGrid.y);\n    float lineThicknessAdj = LINE_THICKNESS * (0.5 + u_intensity * 0.5);\n    float lineX = smoothstep(0.0, lineThicknessAdj, distToLineX);\n    float lineY = smoothstep(0.0, lineThicknessAdj, distToLineY);\n    float gridMask = 1.0 - min(lineX, lineY);\n\n    // --- 4. 交叉点计算 ---\n    // (基于 fractGrid，网格单元内部)\n    float distToCenter = distance(fractGrid, vec2(0.5));\n    float dotSizeAdj = DOT_SIZE * (0.5 + 0.5 * sin(timeScaled * 2.0 + cellId.x * 0.5 + cellId.y * 0.3) + u_intensity * 0.5);\n    dotSizeAdj *= (0.8 + random(cellId) * 0.4);\n    float dotMask = 1.0 - smoothstep(0.0, dotSizeAdj, distToCenter);\n\n    // --- 5. 鼠标圆环计算 ---\n    // !!! 使用 vUv 计算到鼠标的距离，确保圆环是圆形的 !!!\n    float distToMouse = distance(vUv, u_mouse);\n    float mouseRingMask = smoothRingMask(distToMouse, mouseRadius, MOUSE_RING_THICKNESS, MOUSE_RING_SMOOTHNESS);\n\n    // --- 6. 颜色混合 ---\n    vec3 finalColor = COLOR_BG;\n    vec3 dynamicLineColor = COLOR_LINE * (0.7 + u_intensity * 0.6);\n    finalColor = mix(finalColor, dynamicLineColor, gridMask);\n    vec3 dynamicDotColor = COLOR_DOT * (0.7 + u_intensity * 0.6);\n    finalColor = mix(finalColor, dynamicDotColor, dotMask * (1.0 - gridMask));\n    // 混合鼠标圆环 (基于圆形的 mouseRingMask)\n    vec3 mouseRingColor = COLOR_LINE * (0.8 + u_intensity * 0.4);\n    finalColor = mix(finalColor, mouseRingColor, mouseRingMask);\n\n    // --- 7. 透明度计算 ---\n    // (透明度效果基于原始 vUv 或时间)\n    float baseAlpha = 0.7;\n    float timeAlphaFactor = 0.1 * sin(timeScaled + vUv.y * 5.0);\n    // 鼠标附近透明度变化 (基于圆形的 mouseFactor)\n    float mouseAlphaFactor = (1.0 - mouseFactor) * 0.1;\n    float finalAlpha = baseAlpha + timeAlphaFactor + mouseAlphaFactor + u_intensity * 0.1;\n    finalAlpha = clamp(finalAlpha, 0.1, 1.0);\n\n    // --- 输出最终颜色 ---\n    gl_FragColor = vec4(finalColor, finalAlpha);\n}\n"
}