{
  "id": "Shaders5",
  "isDefault": false,
  "vertex": "// varying vec2 vUv; // Three.js r150+ 会自动传递 uv\n\nvoid main() {\n  // vUv = uv; // 传递 UV 坐标给 Fragment Shader (r150+ 不需要手动传递)\n  // 直接使用内置的 position 属性\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
  "fragment": "precision mediump float;\n\nuniform float u_time;       // 当前动画时间\nuniform vec2  u_resolution; // 屏幕分辨率\nuniform vec2  u_mouse;      // 归一化的鼠标坐标 (0.0 到 1.0)\nuniform float u_intensity;  // 键盘输入强度 (0.0 到 1.0)\n\n// varying vec2 vUv; // 从 Vertex Shader 接收 UV 坐标 (r150+ 不需要手动声明)\n\n// 2D 伪随机数生成器\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 鼠标影响计算函数\nfloat mouseInfluence(vec2 uv, vec2 mouse, float radius, float strength) {\n    float dist = distance(uv, mouse);\n    // 使用 smoothstep 在半径内平滑过渡影响，乘以强度\n    return smoothstep(radius, 0.0, dist) * strength;\n}\n\nvoid main() {\n    // 将像素坐标归一化到 [0,1]，并调整Y轴方向，使原点在左下角\n    vec2 uv = gl_FragCoord.xy / u_resolution;\n    // vec2 uv = vUv; // 使用varying变量 (r150+ 不需要)\n\n    // --- 鼠标交互参数 ---\n    // 鼠标影响半径，受强度影响轻微变大\n    float mouseRadius = 0.1 + u_intensity * 0.05;\n    // 鼠标影响强度，受强度影响显著变大\n    float mouseStrength = 0.5 + u_intensity * 0.8;\n    // 计算当前像素受鼠标影响的因子 (0.0 到 mouseStrength)\n    float mouseFactor = mouseInfluence(uv, u_mouse, mouseRadius, mouseStrength);\n\n    // --- 数字雨参数 ---\n    // 字符雨列的数量，可以调整这个值改变列的密度\n    float numColumns = 80.0; // 列数随强度增加\n    // 字符在列中的垂直密度/重复频率，值越小字符越稀疏\n    float charDensity = 0.9; // 密度随强度降低（视觉上更快）\n    // 基础下落速度\n    float baseSpeed = 0.2;\n    // 字符亮度衰减速度，值越大衰减越快\n    float fadeSpeed = 2.0 + u_intensity * 2.0;\n    // 字符高亮部分的长度比例\n    float highlightLength = 0.05 + mouseFactor * 0.1; // 鼠标靠近时高亮更长\n\n    // --- 计算过程 ---\n    // 将UV坐标映射到列索引和列内垂直位置\n    float column_x = floor(uv.x * numColumns);\n    vec2 column_uv = vec2(column_x / numColumns, uv.y); // 使用列的起始x坐标\n\n    // 为每列生成随机偏移和速度变化\n    float columnRand = random(vec2(column_x, column_x));\n    float timeOffset = columnRand * 100.0; // 每列的起始时间偏移\n    float speedMultiplier = 0.5 + columnRand * 1.0; // 每列的速度变化因子\n\n    // 计算字符在垂直方向上的位置，随时间向下移动\n    // (u_time + timeOffset) * speed * speedMultiplier: 总的移动距离\n    // uv.y: 当前像素的原始y坐标\n    // 添加 mouseFactor * 0.5 : 鼠标靠近时稍微加速下落\n    float yPos = uv.y + (u_time + timeOffset) * baseSpeed * speedMultiplier + mouseFactor * 0.5;\n    // 使用 fract 获取小数点后的部分，实现循环流动效果\n    // 乘以 charDensity 控制字符出现的频率\n    float charCycle = fract(yPos / charDensity);\n    // 向上取整得到当前字符在循环中的整数索引（用于随机化字符）\n    float charIndex = floor(yPos / charDensity);\n\n    // 生成当前位置的随机字符“亮度”（模拟不同字符）\n    // 使用列索引和字符索引作为随机种子\n    float charValue = random(vec2(column_x, charIndex));\n\n    // --- 亮度与颜色计算 ---\n    // 计算头部高亮效果：charCycle接近1.0时最亮\n    // pow(..., fadeSpeed): 控制亮度的衰减曲线，值越大，头部越亮，尾部越暗\n    // 乘以 charValue 实现字符闪烁/变化\n    float brightness = pow(1.0 - charCycle, fadeSpeed) * charValue;\n\n    // 头部高亮处理：让最头部的字符更亮 (白色)\n    float headHighlight = smoothstep(1.0 - highlightLength, 1.0, 1.0 - charCycle);\n    // 基础颜色（绿色）\n    vec3 baseColor = vec3(0.0, 0.8, 0.2); // 基础绿色\n    // 高亮颜色（亮白或亮绿）\n    // 鼠标靠近时偏白，强度高时也偏白\n    vec3 highlightColor = mix(vec3(0.6, 1.0, 0.7), vec3(1.0), mouseFactor + u_intensity * 0.5);\n\n    // 混合基础色和高亮色\n    vec3 finalColor = mix(baseColor, highlightColor, headHighlight);\n\n    // 应用最终计算的亮度\n    finalColor *= brightness;\n\n    // 鼠标影响区域的额外效果：轻微颜色扰动\n    // 鼠标影响因子越大，颜色越偏向一点点青色\n    finalColor = mix(finalColor, finalColor * vec3(0.8, 1.0, 1.1), mouseFactor * 0.5);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n}"
}