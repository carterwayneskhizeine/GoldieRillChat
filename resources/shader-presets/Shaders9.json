{
  "id": "Shaders9",
  "isDefault": false,
  "vertex": "// 无需版本声明，Three.js 会自动处理\n// Three.js 提供内置的 attribute \"position\"\n// 无需修改，直接传递顶点位置\nvoid main() {\n    gl_Position = vec4(position, 1.0);\n}",
  "fragment": "precision highp float; // Use high precision\n\nuniform vec2 u_resolution;\nuniform float u_time;\nuniform vec2 u_mouse;\nuniform float u_intensity;          // Raw input intensity (0-1)\n// *** NEW UNIFORM for fade out timing ***\nuniform float u_time_since_inactive; // Seconds since u_intensity dropped below threshold\n\n// --- Constants ---\nconst float lookSensitivity = 0.25;\nconst float baseStarBrightness = 1.0;\nconst float movingStarBrightness = 1.5;\nconst float intensityThreshold = 0.01;   // Threshold to activate complex effects\nconst float fadeOutDuration = 3.0;       // Duration of fade out in seconds\n\n// --- Functions ---\nfloat hash(vec2 p) { /* ... (unchanged hash function) ... */\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\nfloat starFlickerFactor(vec2 p, float t) { /* ... (unchanged flicker function) ... */\n    float randomPhase = hash(p) * 6.28318;\n    float randomSpeed = 1.0 + hash(p + vec2(1.3, 2.7)) * 3.0;\n    return 0.65 + 0.35 * sin(t * randomSpeed + randomPhase);\n}\nvec2 rotate(vec2 p, float a) { /* ... (unchanged rotate function) ... */\n    float s = sin(a); float c = cos(a);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nfloat glow(float d, float r, float i) { /* ... (unchanged glow function) ... */\n    return pow(r / max(d, 1e-6), i);\n}\n// Note: mouseInfluence is not directly used in the final composition of this version\n// float mouseInfluence(vec2 uv, vec2 m, float r, float s){ /* ... */ }\n\nvoid main() {\n    // 1. --- Base Coordinate Setup ---\n    vec2 baseUV = gl_FragCoord.xy / u_resolution.xy;\n    vec2 p = baseUV; p.x *= u_resolution.x / u_resolution.y; // Corrected screen pos\n    vec2 mouseDeviation = u_mouse - vec2(0.5);\n    vec2 viewOffset = -mouseDeviation * lookSensitivity;\n    vec2 mousePosCorrected = u_mouse; mousePosCorrected.x *= u_resolution.x / u_resolution.y;\n    vec2 blackHoleScreenCenter = mousePosCorrected; // Center on screen coords\n\n    // 2. --- Calculate Effective Intensity & Radius (Handles Fade Out) ---\n    // Intensity for *activating* effects based on direct input\n    float activeEffectIntensity = smoothstep(intensityThreshold, intensityThreshold * 2.0, u_intensity);\n    // Intensity factor for *fading out* based on time since inactive\n    float fadeOutFactor = 1.0 - smoothstep(0.0, fadeOutDuration, u_time_since_inactive);\n    // Final visual effect intensity: Use fade-out if active, otherwise use activation intensity\n    float effectIntensity;\n    if (u_time_since_inactive > 0.0 && u_intensity <= intensityThreshold) {\n        effectIntensity = fadeOutFactor; // Currently fading out\n    } else {\n        effectIntensity = activeEffectIntensity; // Currently active or fully faded\n    }\n    effectIntensity = max(0.0, effectIntensity); // Ensure non-negative\n\n    // Calculate current Black Hole Radius (shrinks during fade out)\n    float baseBHRadius = 0.0; // Radius when fully faded (can be > 0 if desired)\n    float activeBHRadius = 0.15 + u_intensity * 0.05; // Radius when active (uses raw intensity)\n    float maxPossibleActiveRadius = 0.15 + 1.0 * 0.05; // Approx radius when fade started\n    float currentBHRadius;\n     if (u_time_since_inactive > 0.0 && u_intensity <= intensityThreshold) {\n         // Fading out: Interpolate from approx start radius to base radius\n         currentBHRadius = mix(baseBHRadius, maxPossibleActiveRadius, fadeOutFactor);\n     } else {\n         // Active or fully inactive: Interpolate from base to active radius based on activation intensity\n         currentBHRadius = mix(baseBHRadius, activeBHRadius, activeEffectIntensity);\n     }\n    currentBHRadius = max(0.001, currentBHRadius); // Prevent radius becoming zero/negative\n\n    // Distance from pixel to BH center on screen\n    float distToCenter = distance(p, blackHoleScreenCenter);\n\n    // 3. --- Gravitational Lensing ---\n    float distortionStrength = (0.1 + u_intensity * 0.05) * effectIntensity; // Use faded effectIntensity\n    vec2 starLookupUV = baseUV + viewOffset; // Start with view shift\n    if (distToCenter > currentBHRadius && effectIntensity > 0.0) { // Lens outside BH, only when effect active/fading\n        vec2 direction = normalize(p - blackHoleScreenCenter + 1e-6);\n        float lensEffectAmount = distortionStrength * (currentBHRadius / max(distToCenter, 1e-6)) * 0.2;\n        starLookupUV = starLookupUV - direction * lensEffectAmount; // Apply lensing\n    }\n\n    // 4. --- Starfield Generation ---\n    vec3 starColor = vec3(0.0);\n    float moveIntensity = smoothstep(0.05, 0.4, length(mouseDeviation));\n    float currentStarBrightnessFactor = mix(baseStarBrightness, movingStarBrightness, moveIntensity);\n    vec3 currentStarBaseColor = vec3(currentStarBrightnessFactor);\n    for (int i = 0; i < 4; i++) { /* ... (star generation loop unchanged, uses starLookupUV) ... */\n        float scaleFactor = pow(2.5, float(i));\n        float layerIntensity = 0.6 / (float(i) + 1.0);\n        vec2 starGridBaseUV = starLookupUV * 400.0 * scaleFactor;\n        vec2 starGridPos = floor(starGridBaseUV);\n        float starExistence = smoothstep(0.96, 1.0, hash(starGridPos / scaleFactor));\n        if (starExistence > 0.0) {\n            float flicker = starFlickerFactor(starGridPos, u_time);\n            float finalBrightness = starExistence * flicker * layerIntensity;\n            starColor += currentStarBaseColor * finalBrightness;\n        }\n    }\n    starColor = smoothstep(0.0, 1.5, starColor);\n\n    // 5. --- Complex Black Hole Effects (Only when effectIntensity > 0) ---\n    vec3 accretionEffectsColor = vec3(0.0);\n    if (effectIntensity > 0.0) {\n        // --- Accretion Disk Calculations ---\n        float accretionDiskRadius = currentBHRadius * 3.0; // Use current (potentially shrinking) radius\n        float innerEdge = currentBHRadius * 1.2;\n        float outerEdge = accretionDiskRadius;\n\n        vec3 hotColor = vec3(1.0, 0.6, 0.0); // Orange/Yellow\n        // *** ENHANCEMENT: Make cool color more vibrant blue ***\n        vec3 coolColor = vec3(0.1, 0.5, 1.0); // Vibrant Blue\n\n        float diskMask = smoothstep(innerEdge, innerEdge * 1.1, distToCenter) *\n                         smoothstep(outerEdge, outerEdge * 0.8, distToCenter);\n\n        if (diskMask > 0.0) {\n            vec2 relativeP = p - blackHoleScreenCenter;\n            // Simple constant rotation for now, can be linked to intensity if desired\n            float rotationSpeed = 0.3;\n            vec2 rotatedRelativeP = rotate(relativeP, u_time * rotationSpeed);\n            float angle = atan(rotatedRelativeP.y, rotatedRelativeP.x);\n\n            float diskT = clamp((distToCenter - innerEdge) / (outerEdge - innerEdge), 0.0, 1.0);\n            vec3 diskColor = mix(hotColor, coolColor, diskT * diskT); // Mix hot to cool\n\n            float diskNoise = hash(vec2(angle * 10.0, distToCenter * 20.0) + u_time * 0.5);\n            diskColor *= 0.8 + diskNoise * 0.4; // Apply base noise\n\n            // *** ENHANCEMENT: Add Rotating Stripes ***\n            float stripeAngleFactor = angle * 120.0; // How many stripes (adjust 6.0)\n            float stripeTimeFactor = u_time * -0.8; // Stripe rotation speed/direction\n            // Create smooth periodic stripes using sine\n            float stripes = 0.5 + 0.5 * sin(stripeAngleFactor + stripeTimeFactor);\n            stripes = smoothstep(0.6, 0.9, stripes); // Make stripes sharper/brighter peaks\n            // Mix stripe color (brighter blue/white) with disk color\n            vec3 stripeColor = vec3(0.8, 0.9, 1.0); // Bright blue/white stripe color\n            diskColor = mix(diskColor, stripeColor, stripes * 0.5); // Mix stripes in (adjust 0.5 opacity)\n\n\n            accretionEffectsColor += diskColor * diskMask;\n\n            // Particle Flow (Simplified, enhance color)\n            if (distToCenter < outerEdge * 0.9) {\n                float spiral = fract((angle + u_time * rotationSpeed * 1.5) / 6.28318 * 12.0);\n                spiral = smoothstep(0.4, 0.5, spiral) * smoothstep(0.6, 0.5, spiral);\n                float flowIntensity = smoothstep(innerEdge, outerEdge * 0.7, distToCenter);\n                // *** ENHANCEMENT: Particle color with hint of blue/cyan ***\n                vec3 particleColor = vec3(1.0, 0.7, 0.5);\n                accretionEffectsColor += spiral * flowIntensity * 0.4 * particleColor * diskMask;\n            }\n        } // End if (diskMask > 0.0)\n\n        // --- Accretion Disk Glow ---\n        float glowIntensityParam = 1.5; // Sharper glow\n        float glowRadius = currentBHRadius * 1.6; // Glow starts slightly further out\n        float baseGlow = glow(distToCenter, glowRadius, glowIntensityParam)\n                         * smoothstep(currentBHRadius * 0.9, currentBHRadius * 1.1, distToCenter); // Fade glow near BH edge\n        // Modulate glow intensity - stronger when active\n        baseGlow *= (0.6 + u_intensity * 0.6); // Use raw u_intensity for glow brightness boost\n\n        // *** ENHANCEMENT: Glow color includes blue ***\n        vec3 glowMixColor = mix(hotColor, vec3(0.7, 0.8, 1.0), 0.6); // Mix orange/yellow with bright blue/white\n        accretionEffectsColor += baseGlow * glowMixColor * 0.4; // Adjust glow opacity (0.4)\n\n    } // End if (effectIntensity > 0.0)\n\n    // 6. --- Final Compositing ---\n    // Mask for the event horizon (using current radius)\n    float eventHorizonMask = smoothstep(currentBHRadius * 0.98, currentBHRadius, distToCenter);\n\n    // Combine: (Stars + Accretion Effects * overall_effect_intensity) * Horizon_Mask\n    vec3 finalColor = (starColor + accretionEffectsColor * effectIntensity) * eventHorizonMask;\n\n    // 7. --- Output ---\n    gl_FragColor = vec4(finalColor, 1.0);\n}"
}