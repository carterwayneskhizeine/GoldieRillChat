在片段着色器Fragment Shader中使用 u_intensity 值来控制视觉效果，例如：

```glsl
   // 噪声计算    
   float noiseScale = 2.0 + u_intensity * 1.5;
   
   // 最终颜色计算
   float finalColor = mix(    
       mix(baseColor, color2, n),    
       activeColor,    
       u_intensity * 0.3    
   );
   
   // 透明度计算
   float alpha = 0.7 + 0.15 * sin(u_time + distortedUV.y * 3.0) + u_intensity * 0.15;
```

ThreeJS_Shaders AI提问示例，使用Ctrl+Shift+i打开Console控制台查看Shader报错返回给AI修改代码直到成功：

按照以下格式，帮我写一个黑白柔和迷幻循环的效果。具体要求如下：

**效果描述**：  
  - 由黑白颜色组成;
  - 其中有一个圆形图案;  
  - 可能是螺旋形或一系列同心圆;
  - 圆形在循环旋转。

---

**代码要求：**  
- 请完全重写 GLSL 代码，不基于给定代码的效果和逻辑做简单修改；  
- 创建全新的 Vertex Shader 和 Fragment Shader；  
- 直接使用内置的 **position** 属性，无需重复声明；  
- 避免版本声明：代码中完全没有 `#version` 行，防止与 Three.js 自动注入的版本声明冲突。

**输出格式：**  
请按照以下 Markdown 格式输出，并在代码中附上必要的参数调整注释：

---

## Vertex Shader
```glsl
// 此处不写任何版本声明，Three.js 会自动注入
// 直接使用内置的 attribute "position"（由 Three.js 提供）
void main() {
    gl_Position = vec4(position, 1.0);
}
```

## Fragment Shader
```glsl
precision mediump float;

uniform float u_time;
uniform float u_intensity;
uniform vec2 u_resolution;

// 生成流动线条的噪声函数
float flowNoise(vec2 uv) {
    float phase = u_time * 0.3;
    return sin(uv.x * 10.0 + phase) * 
           sin(uv.y * 7.0 + phase * 1.3) * 
           sin((uv.x + uv.y) * 5.0 + phase * 0.7);
}

// 动态网格生成器
float dynamicGrid(vec2 uv) {
    uv *= 8.0 + u_intensity * 4.0; // 网格密度随强度变化
    vec2 grid = fract(uv) - 0.5;
    float cell = smoothstep(0.35, 0.45, length(grid));
    
    // 让网格线随时间波动
    float pulse = 0.5 + 0.5 * sin(u_time * 2.0 + uv.x * 3.0);
    return cell * pulse;
}

// 分形生成器（三层叠加）
float fractalPattern(vec2 uv) {
    float layer1 = flowNoise(uv * 2.0);
    float layer2 = flowNoise(uv * 4.0 + vec2(u_time * 0.2));
    float layer3 = flowNoise(uv * 8.0 - vec2(u_time * 0.3));
    return (layer1 * 0.6 + layer2 * 0.3 + layer3 * 0.1);
}

void main() {
    // 坐标系统调整
    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution) / min(u_resolution.x, u_resolution.y);
    uv *= 1.0 + u_intensity * 0.5; // 强度控制画面缩放
    
    // 基础图案组合
    float fractal = fractalPattern(uv);
    float grid = dynamicGrid(uv * 2.0);
    
    // 动态旋转系统
    float rotation = u_time * 0.1 + u_intensity * 0.3;
    uv = mat2(cos(rotation), -sin(rotation),
              sin(rotation), cos(rotation)) * uv;
    
    // 核心视觉效果
    float wave = sin(length(uv * 3.0) * 5.0 - u_time * 2.0);
    float mask = smoothstep(0.3, 0.7, wave + fractal);
    
    // 多层叠加效果
    float final = mask * 0.7 + grid * 0.3;
    final *= 1.0 - length(uv) * 0.4; // 中心强化
    
    // 强度控制的辉光效果
    float glow = pow(final, 2.0) * (1.0 + u_intensity * 3.0);
    final = min(final + glow, 1.0);
    
    gl_FragColor = vec4(vec3(final * 0.9), 1.0);
}
```